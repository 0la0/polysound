<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../helpers/midi.html">
<link rel="import" href="../helpers/matrix.html">

<dom-module id="launchpad-sequencer">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <div class="matrix-list">

      <sequencer-matrix
        class="matrix"
        number-of-steps="8"
        number-of-rows="8"
        clip-manager="{{clipManager}}"
        clip-label="Launchpad Clip">
      </sequencer-matrix>

    </div>

  </template>

  <script>
    (function() {
      'use strict';

      class LaunchpadSequencer {

        beforeRegister() {
          this.is = 'launchpad-sequencer';

          this.properties = {
            instrumentList: {
              type: Array
            }
          };

          this.listeners = {};
        }

        ready() {}
        attached() {
          this.isReset = true;
          this.particles = [];
          this.schedulable = buildSchedulable.call(this);
          app.scheduler.register(this.schedulable);

          let matrixNodeList = this.getElementsByClassName('matrix');
          this.viewMatrix = Array.prototype.slice.call(matrixNodeList)[0];
          this.launchpad = buildMidiDevice(app.audio.midiDeviceFactory, this.viewMatrix, this.particles);
          this.clipManager = buildClipManager(this.matrixList, this.launchpad, () => {});
        }

        detached() {
          app.scheduler.deregister(this.schedulable);
        }
        attributeChanged() {}
      }
      Polymer(LaunchpadSequencer);


      //--- js imports ---//
      let midiHelpers = buildMidiHelpers();
      const StatusMap = midiHelpers.StatusMap;
      let getObjectFromMessage = midiHelpers.getObjectFromMessage;
      let getMessageFromObject = midiHelpers.getMessageFromObject;
      //--- importing Matrix as a class of static functions ---//

      const RunDirection = {
        CLOCKWISE: 'CLOCKWISE',
        COUNTER_CLOCKWISE : 'COUNTER_CLOCKWISE',
        CASCADE: 'CASCADE',
        FALL: 'FALL'
      };

      let runBehaviors = buildRunBehaviors();
      let touchBehaviors = buildTouchBehaviors();

      function buildClipManager (matrixList, midiDevice, setActiveIndex) {
        return {
          queueActive: () => { },
          onMatrixChange: (matrixElement, row, column, value) => {
            //TODO: create an event bus
            console.log('onMatrixChange', row, column, value);
          }
        };
      }


      function buildMidiDevice (midiDeviceFactory, viewMatrix, particles) {
        const Velocity = {
          RED: 15,
          GREEN: 60,
          YELLOW: 62,
          AMBER: 63,
          OFF: 0,
          ON: 127
        };

        let launchpad = midiDeviceFactory.getDeviceByName('Launchpad Mini');
        let touchList = [];

        function eventIsInMatrix (message, row, column) {
          return row < 8 && column < 8;
        }

        function eventIsInTopBar (message, row, column) {
          return message.command === 11;
        }

        function eventIsInSideBar (message, row, column) {
          return column === 8;
        }

        function onmidimessage (event) {
          let message = getObjectFromMessage(event.data);
          let noteValue = message.note;
          let row = Math.floor(message.note / 16);
          let column = message.note % 16;

          // if (eventIsInMatrix(message, row, column)) {
          //
          // }
          if (eventIsInTopBar(message, row, column)) {
            return;
          }
          else if (eventIsInSideBar(message, row, column)) {
            if (message.value === 127 && particles[row]) {
              particles[row].particleModel.changeDirection();
            }
            return;
          }


          let messageObject;
          if (message.value === Velocity.ON) {
            touchList.push({row: row, column: column});
            messageObject = {
              command: StatusMap.NOTE_ON,
              status: 0,
              note: noteValue,
              value: Velocity.GREEN
            };
          }
          if (message.value === Velocity.OFF) {
            messageObject = {
              command: StatusMap.NOTE_OFF,
              status: 0,
              note: noteValue,
              value: Velocity.OFF
            };
            touchList = touchList.filter((touchState) => {
              return touchState.row !== row && touchState.column !== column;
            });
          }
          if (messageObject) {
            launchpad.output.send(getMessageFromObject(messageObject));
          }
          particles.forEach(particle => particle.applyTouchStates(touchList));
        }

        function renderParticle (currentParticle, lastParticle) {
          let noteOn = currentParticle.row * 16 + currentParticle.column;
          let noteOff = lastParticle.row * 16 + lastParticle.column;
          let messageObjectOn = { command: 9, status: 0, note: noteOn, value: Velocity.AMBER };
          let messageObjectOff = { command: 8, status: 0, note: noteOff, value: Velocity.OFF };

          launchpad.output.send(getMessageFromObject(messageObjectOn));
          launchpad.output.send(getMessageFromObject(messageObjectOff));
        }

        if (launchpad.input) {
          launchpad.input.onmidimessage = onmidimessage;
        }
        launchpad.renderParticle = (launchpad.output) ? renderParticle : () => {};
        return launchpad;
      }

      function buildSchedulable () {

        let topParticle = new ParticleDriver(0, 0, 8, 2, RunDirection.CLOCKWISE);
        let middleParticle = new ParticleDriver(0, 2, 8, 2, RunDirection.COUNTER_CLOCKWISE);
        let bottomLeftParticle = new ParticleDriver(0, 4, 4, 4, RunDirection.COUNTER_CLOCKWISE);
        let bottomRightParticle = new ParticleDriver(4, 4, 4, 4, RunDirection.CASCADE);
        let fall = new ParticleDriver(7, 0, 1, 8, RunDirection.FALL);
        this.particles = [topParticle, bottomLeftParticle, fall];
        window.particles = this.particles;

        return {
          processTick: (beatNumber, time) => {
            beatNumber = beatNumber % this.width;

            //TODO: implement instrument logic
            // let columnData = this.viewMatrix.getColumnValueList(beatNumber);
            // columnData.forEach( (matrixElement, index) => {
            //   // if (matrixElement && this.instrumentList) {
            //   //   this.instrumentList[index].forEach((instrument) => {
            //   //     instrument.play(0, time);
            //   //   });
            //   // }
            // });
          },
          render: (beatNumber, lastBeatNumber) => {
            if (!this.isReset) {
              this.particles.forEach(particle => particle.run());
            }
            this.particles.forEach((particle) => {
              this.viewMatrix.renderCell(particle.currentValue, particle.lastValue, this.isReset);
              this.launchpad.renderParticle(particle.currentValue, particle.lastValue, this.isReset);
            });
            if (this.isReset) {
              this.isReset = false;
            }
          },
          start: () => {
            this.isReset = true;
          },
          stop: () => {
            this.viewMatrix.stop();
          }
        }
      }

      /**
        * A particle driver has a particle and manages its state
        **/
      class ParticleDriver {

        constructor (x, y, width, height, runSequence) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;

          this.particleModel = ParticleBuilder.create(x, y, width, height, runSequence);
          this.currentValue = this.particleModel.getCurrentState();
          this.lastValue = this.currentValue;
        }

        run () {
          this.lastValue = this.currentValue;
          this.currentValue = this.particleModel.run();
          return this.currentValue;
        }

        applyTouchStates (touchStates) {
          this.particleModel.processTouch(touchStates, this.x, this.y, this.width, this.height);
        }

      }


      function buildTouchBehaviors () {

        function getActiveTouchStates (touchStates, x, y, width, height) {
          return touchStates.filter((touchState) => {
            let xIsInBounds = touchState.column >= x && touchState.column <= (x + width);
            let yIsInBounds = touchState.row >= y && touchState.row <= (y + height);
            return xIsInBounds && yIsInBounds;
          });
        }

        function adjustSize (touchStates, x, y, width, height) {
          let activeStates = getActiveTouchStates.apply(this, arguments);

          if (activeStates.length > 1) {
            let lowerBound = activeStates[0];
            let upperBound = activeStates[1];

            let newWidth = Math.abs(upperBound.column - lowerBound.column);
            let newHeight = Math.abs(upperBound.row - lowerBound.row);
            let newX = Math.min(lowerBound.column, upperBound.column);
            let newY = Math.min(lowerBound.row, upperBound.row);

            this.setMatrix(newX, newY, newWidth + 1, newHeight + 1);
          }
        }

        function setRowValue (touchStates, x, y, width, height) {
          let activeStates = getActiveTouchStates.apply(this, arguments);
          if (activeStates.length) {
            this.targetRowIndex = activeStates[0].row;
          }
        }

        return {
          adjustSize: adjustSize,
          setRowValue: setRowValue
        }
      }

      function buildRunBehaviors () {

        function rotate () {
          if (++this.columnIndex >= this.matrix[this.rowIndex].length) {
            this.matrix = Matrix.rotateCounterClockwise(this.matrix);
            this.columnIndex = 1;
            //a second check covers the case of a one dimensional matrix
            if (this.columnIndex >= this.matrix[this.rowIndex].length) {
              this.matrix = Matrix.rotateCounterClockwise(this.matrix);
              this.columnIndex = 1;
            }
          }
          return this.matrix[this.rowIndex][this.columnIndex];
        }

        function cascade () {
          if (++this.columnIndex >= this.matrix[this.rowIndex].length) {

            this.matrix = Matrix.rotate180(this.matrix);
            if (++this.rotateCnt % 2 !== 0) {
              this.matrix = Matrix.shiftDown(this.matrix);
              this.matrix = Matrix.shiftDown(this.matrix);
            }
            this.columnIndex = 0;

          }
          return this.matrix[this.rowIndex][this.columnIndex];
        }

        function fall () {
          if (++this.rowIndex >= this.matrix.length) {
            this.rowIndex = this.targetRowIndex || 0;
          }
          return this.matrix[this.rowIndex][this.columnIndex];
        }

        return {
          rotate: rotate,
          cascade: cascade,
          fall: fall
        }

      }


      class BaseParticleSystem {

        constructor (x, y, width, height) {
          this.rowIndex = 0;
          this.columnIndex = 0;
          this.rotateCnt = 0;
          this.runCnt = 0;
          this.setMatrix(x, y, width, height);
        }

        changeDirection () {
          this.matrix = Matrix.reflectY(this.matrix);
        }

        getCurrentState () {
          return this.matrix[this.rowIndex][this.columnIndex];
        }

        setMatrix (x, y, width, height) {
          this.matrix = Matrix.create(x, y, width, height);
        }

        rotate (isClockwise) {
          this.matrix = isClockwise ?
            Matrix.rotateClockwise(this.matrix) :
            Matrix.rotateCounterClockwise(this.matrix);
        }

        setRunBehavior (runBehavior) {
          this.runBehavior = runBehavior;
        }

        run () {
          if (this.runBehavior) { return this.runBehavior.call(this); }
        }

        setTouchBehavior (touchBehavior) {
          this.touchBehavior = touchBehavior;
        }

        processTouch (events, x, y, width, height) {
          if (this.touchBehavior) { return this.touchBehavior.apply(this, arguments); }
        }

      }

      class ParticleBuilder {

        static create (x, y, width, height, runBehavior) {

          let particleSystem = new BaseParticleSystem(x, y, width, height);
          if (runBehavior === RunDirection.CLOCKWISE) {
            particleSystem.setRunBehavior(runBehaviors.rotate);
            particleSystem.setTouchBehavior(touchBehaviors.adjustSize);
          }
          else if (runBehavior === RunDirection.COUNTER_CLOCKWISE) {
            particleSystem.changeDirection();
            particleSystem.setRunBehavior(runBehaviors.rotate);
            particleSystem.setTouchBehavior(touchBehaviors.adjustSize);
          }
          else if (runBehavior === RunDirection.CASCADE) {
            particleSystem.setRunBehavior(runBehaviors.cascade);
            particleSystem.setTouchBehavior(touchBehaviors.adjustSize);
          }
          else if (runBehavior === RunDirection.FALL) {
            particleSystem.setRunBehavior(runBehaviors.fall);
            particleSystem.setTouchBehavior(touchBehaviors.setRowValue);
          }
          return particleSystem;
        }

      }


    })();
  </script>

</dom-module>
